
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions", "views"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  extensions = [pgcrypto]
}

model User  {
  id                  String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  username            String        @unique
  fullname            String?
  email               String        @unique
  phone               String?
  password            String
  lastpass            String[]
  expirepass          DateTime?
  twoFA               Boolean?      @default(false)
  emailVerified       DateTime?     
  image               String?
  status              String        @default("ACTIVE")
  role                UserRole[]
  profile             Profile?
  verification_token  VerificationToken[]
  session_token       Session[]
  accounts            Account[]

  createdAt           DateTime      @default(now()) @db.Timestamptz(6)
  updatedAt           DateTime      @updatedAt()

  @@index([username, email], map: "User_Index_00")
}

model Profile {
  id             Int       @id @default(autoincrement())
  userId         String    @unique @db.Uuid
  firstname      String
  second_name    String?
  last_name      String
  second_surname String?
  birthday       DateTime?
  gender         String?
  phone          String?
  metadata       Json?
  localityId     Int?
  picture        String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  user           User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId], map: "Profile_Index_00")
}

model Account {
  userId            String   @db.Uuid
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
 
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  @@id([provider, providerAccountId])
}

model Role {
  id          Int           @id @default(autoincrement())
  name        String        @unique
  description String?
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
  user        UserRole[]

  @@index([name], map: "Roles_Index_00")
}

model UserRole {
  id         Int      @id @default(autoincrement())
  user_id    String   @db.Uuid
  rol_id     Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  rol        Role     @relation(fields: [rol_id], references: [id])
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@index([user_id, rol_id], map: "User_Roles_Index_00")
}


model VerificationToken  {
  sessionToken  String   @unique
  code          Int?
  identifier    String   @db.Uuid
  expires       DateTime
  ip            String?  
  user          User     @relation(fields: [identifier], references: [id], onDelete: Cascade)

  @@index([sessionToken], map: "Service_token_Index_00")
}

model ConfigAuth {
  id             Int      @id @default(autoincrement())
  https          Boolean?
  useEmail       Boolean?
  max_last_pass  Int?   /// number of last passwords not allowed
  time_life_pass Int?   /// password lifetime in days
  twoFA          Boolean?   /// double verification general
  time_life_code Int?   /// verification code lifetime in seconds
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
}

model Session  {
  id             String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId         String   @db.Uuid
  sessionToken   String   @unique
  expires        Int
  last_activity  DateTime?
  is_active      Boolean  @default(true)
  ip             String?  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  user           User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}


// model states {
//   id             Int              @id @default(autoincrement())
//   name           String
//   created_at     DateTime         @default(now()) @db.Timestamptz(6)
//   updated_at     DateTime         @default(now()) @db.Timestamptz(6)
//   localities     localities[]
//   municipalities municipalities[]
//   parishes       parishes[]

//   @@index([id, name], map: "States_Index_00")
// }

// model municipalities {
//   id         Int          @id @default(autoincrement())
//   name       String
//   state_id   Int
//   created_at DateTime     @default(now()) @db.Timestamptz(6)
//   updated_at DateTime     @default(now()) @db.Timestamptz(6)
//   localities localities[]
//   states     states       @relation(fields: [state_id], references: [id], onDelete: Cascade)
//   parishes   parishes[]

//   @@index([id, name, state_id], map: "Municipalities_Index_00")
// }

// model parishes {
//   id              Int            @id @default(autoincrement())
//   name            String
//   state_id        Int
//   municipality_id Int
//   created_at      DateTime       @default(now()) @db.Timestamptz(6)
//   updated_at      DateTime       @default(now()) @db.Timestamptz(6)
//   localities      localities[]
//   municipality    municipalities @relation(fields: [municipality_id], references: [id], onDelete: Cascade)
//   states          states         @relation(fields: [state_id], references: [id], onDelete: Cascade)

//   @@index([id, name, municipality_id], map: "Parishes_Index_00")
// }

// model localities {
//   id              Int              @id @default(autoincrement())
//   state_id        Int
//   municipality_id Int
//   parish_id       Int
//   created_at      DateTime         @default(now()) @db.Timestamptz(6)
//   updated_at      DateTime         @default(now()) @db.Timestamptz(6)
//   municipalities  municipalities   @relation(fields: [municipality_id], references: [id], onDelete: Cascade)
//   parishes        parishes         @relation(fields: [parish_id], references: [id], onDelete: Cascade)
//   states          states           @relation(fields: [state_id], references: [id], onDelete: Cascade)

//   @@index([state_id, municipality_id, parish_id], map: "Localities_Index_00")
// }

// model data_saime {
//   id             Int       @id @default(autoincrement())
//   nationality    String
//   cedula         Int
//   firstname      String?
//   second_name    String?
//   last_name      String?
//   second_surname String?
//   birthday       DateTime?
//   gender         String?
//   created_at     DateTime  @default(now()) @db.Timestamptz(6)
//   updated_at     DateTime? @default(now()) @db.Timestamptz(6)

//   @@index([cedula], map: "Data_Saime_Index_00")
// }

// model categories {
//   id              Int              @id @default(autoincrement())
//   group           String
//   name            String
//   created_at      DateTime         @default(now()) @db.Timestamptz(6)
//   updated_at      DateTime         @default(now()) @db.Timestamptz(6)

// }

// /// The underlying view does not contain a valid unique identifier and can therefore currently not be handled by Prisma Client.
// view localities_full {
//   id              Int @unique
//   state_id        Int?
//   state           String?
//   municipality_id Int?
//   municipality    String?
//   parish_id       Int?
//   parish          String?
//   full_location   String?

// }